/* eslint-disable no-continue, no-cond-assign, no-param-reassign */

// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
// Filter out any ShStMatches that FAIL a directionality test.

import _ from 'lodash';

import {
  SharedStreetsMatchFeature,
  TargetMapPathMatches,
} from '../../../../utils/TargetMapDatabases/TargetMapDAO';

import getCospatialityOfLinestrings from '../../../../utils/gis/getCospatialityOfLinestrings';

import buildShstMatchSubGraphsPerTargetMapEdge from './buildShstMatchSubGraphsPerTargetMapEdge';

import createPathLineStrings from './createPathLineStrings';

export function getPathsPairwiseCospatiality(pathLineStrings) {
  return pathLineStrings.reduce((acc, S, sIdx) => {
    for (let tIdx = sIdx + 1; tIdx < pathLineStrings.length; ++tIdx) {
      const T = pathLineStrings[tIdx];
      try {
        const cospatiality = getCospatialityOfLinestrings(S, T);
        acc.push({
          sIdx,
          tIdx,
          cospatiality,
        });
      } catch (err) {
        console.error(JSON.stringify({ S, T }, null, 4));
        throw err;
      }
    }

    return acc;
  }, []);
}

export function getShstMatchesById(targetMapPathMatches: TargetMapPathMatches) {
  return targetMapPathMatches.reduce(
    // This GTFS shape segment's shstMatches.
    (
      acc: Record<SharedStreetsMatchFeature['id'], SharedStreetsMatchFeature>,
      { shstMatches },
    ) => {
      if (shstMatches !== null) {
        // For each Shst match for this GTFS shape segment.
        for (let i = 0; i < shstMatches.length; ++i) {
          const shstMatch = shstMatches[i];

          // Index that shstMatch by it's id (autogenerated by SQLite).
          acc[shstMatch.id] = shstMatch;
        }
      }

      return acc;
    },
    {},
  );
}

// Input
//   The targetMapPathMatches data structure:
//     [
//       {
//         targetMapPathEdge: <GeoJSON feature for the GTFS shape segment.>,
//         shstMatches: [...shst match GeoJSON features for the GTFS shape segment.]
//       },
//       ...
//     ]
//
// Returns a single heuristically-chosen topologically-sorted per-component path
//   for each TargetMap Edge through the graph comprising the Edge's suggested Shst Matches.
//
// FIXME FIXME FIXME: This function MUST return ALL possible traversals, not a single chosen one.
//                    It is the role of the more sophisticated find*Paths algorithms to make choices.
export default function computeSubGraphComponentsTraversals(
  targetMapPathMatches: TargetMapPathMatches,
) {
  if (!targetMapPathMatches?.length) {
    return null;
  }

  const subGraphs = buildShstMatchSubGraphsPerTargetMapEdge(
    targetMapPathMatches,
  );

  if (subGraphs === null) {
    return null;
  }

  return subGraphs.map((subGraph, targetMapPathIdx) => {
    if (subGraph === null) {
      return null;
    }

    const { targetMapPathEdge } = targetMapPathMatches[targetMapPathIdx];

    const shstMatchesById = getShstMatchesById(targetMapPathMatches);

    const pathLineStrings = createPathLineStrings(
      targetMapPathEdge,
      subGraph,
      shstMatchesById,
    );

    const pathsPairwiseCospatiality = getPathsPairwiseCospatiality(
      pathLineStrings,
    );

    // Use finalPaths and pathsPairwiseCospatiality to
    //   1. Remove overlaps IFF same ShSt Refs
    //   ---- Later
    //   2. Toposort the paths
    //   3. Identify matching gaps

    return {
      targetMapPathEdge,
      pathLineStrings,
      pathsPairwiseCospatiality: !_.isEmpty(pathsPairwiseCospatiality)
        ? pathsPairwiseCospatiality
        : null,
    };
  });
}
